#summary One-sentence summary of this page.

= Introduction =


The UI BPEL extension is a piece of the integrated system for providing User Interfaces (UI) for Web service compositions (WSC) specified through BPEL. The overall architecture of the system is shown in following Figure, which partitions its software components into design time, deployment time, and runtime components.

<img src=http://svn.codespot.com/a/eclipselabs.org/bpel-ui/wiki/images/archicture.png title="UI BPEL meta-model" width=600>

== Design Time ==

The design part comprises the BPEL4UI editor with its UI partner link configurator and layout configurator. Starting from a set of web service WSDLs, UI component WSDLs, and HTML templates the application developer graphically models the UI orchestration, and the editor generates a corresponding BPEL4UI specification in output. The composition logic in Figure 5 has been modeled in our BPEL4UI editor, an extended Eclipse BPEL editor with (i) a panel for the specification of the pages in which UI components can be rendered and (ii) a property panel that allows the developer to configure the web pages, to set the properties of UI partner links, and to associate them to place holders in the layout. 

== Deployment Time ==

The deployment of a UI orchestration requires translating the BPEL4UI specification, which is not immediately executable neither by a standard BPEL engine nor by the UI rendering engine (the so-called UI engine, which we discuss in the following), into executable formats. This task is achieved by the BPEL4UI compiler, which, starting from the BPEL4UI specification, the set of used HTML templates and UI component WSDLs, and the system configuration of the runtime part of the architecture, generates three kinds of outputs: 

1. A set of communication channels (to be deployed in the so-called UI engine server), which mediate between the UI engine client (the client browser) and the BPEL engine. These channels are crucial in that they resolve the technology conflict inherently present in BPEL4UI specifications: a BPEL engine is not able to talk to JavaScript UI components running inside a client browser, and UI components are not able to interact with the SOAP interface of a BPEL engine. For each UI component in a page, the compiler therefore generates (i) an event proxy that is able to forward events from the client browser to the BPEL engine and (ii) an event buffer that is able to accept events from the BPEL engine and stores them on behalf of the UI engine client. 

2. A standard BPEL specification containing the distributed UI synchronization and web service orchestration logic. Unlike the BPEL4UI specification, the generated BPEL specification does no longer contain any of the UI-specific constructs introduced in Section 5.1 and can therefore be executed by any standards-compliant BPEL engine. This means that all references to UI component partner links in input to the compilation are rewritten into references to the respective communication channels of the UI components in the UI engine server, also setting the correct, new SOAP endpoints. 

3. A set of UI compositions (one for each page of the application) consisting of the layout of the page, the list of UI components of the page, the assignment of UI components to place holders, the specification of the intra-page UI synchronization logic, and a reference to the client-side runtime framework. Interactions with web services or UI components running in other pages are translated into interactions with local system components (the notification handlers and event forwarders), which manage the necessary interaction with the communication channels via suitable RESTful web service calls. 

Finally, the BPEL4UI compiler also manages the deployment of the generated artifacts in the respective runtime environments. Specifically, the generated communication channels and the UI compositions are deployed in the UI engine server and the standard BPEL specification is deployed in the BPEL engine.  

== Runtime ==

The execution of a UI orchestration requires the setting up and coordination of three independent runtime environments: First, the interaction with the users is managed in the client browser by an event-based JavaScript runtime framework that is able to parse the UI composition stored in the UI engine server, to instantiate UI components in their respective place holders, to configure the notification handlers and event forwarders, and to set up the necessary publish-subscribe logic ruling the event-to-operation mapping of the components running inside the client browser. While event forwarders are called each time an event is to be sent from the client to the BPEL engine, the notification handlers are active components that periodically poll the event buffers of their UI components on the UI engine server in order to fetch possible events coming from the BPEL engine. 

Second, the UI engine server must run the web services implementing the communication channels. In practice we generate standard Java servlets and SOAP web services, which can easily be deployed in a common web server, such as Apache Tomcat. The use of web server technology is mandatory in that we need to be able to accept notifications from the BPEL engine and the UI engine client, which requires the ability of constantly listening. The event buffer is implemented via a simple relational database (in PostgreSQL â€“ http://www.postgresql.org) that manages multiple UI components and distinguishes between instances of UI orchestrations by means of a session key that is shared among all UI components participating in a same UI orchestration instance. 

Third, running the BPEL process requires a BPEL engine. Our choice to rely on standard BPEL allows us to reuse a common engine without the need for any UI-specific extensions. In our case, we use Apache ODE (http://ode.apache.org), which is characterized by a simple deployment procedure for BPEL processes. 

The MarcoFlow system shown in Figure 6 is fully implemented and running (a demo of the tool is available at http://mashart.org/marcoflow/demo.htm). In our test setting, we run the UI engine server and the BPEL engine on the same machine, yet these components could also easily be distributed over different physical machines, a feature that is already supported by our code generator.

==Artifacts==

Our approach relies on X artifacts:
 
 * UI-WSC:  an extension of WSC with user interaction activities. To be compliant with current standards, the model is to rely on existing standards: a standard for WSC (e.g. BPEL) and a standard for describing user interfaces (e.g. UsiXML).
 * Abstract user interface (AUI): this model describes the UI independently to any interaction modality (e.g. graphical modal, vocal modal) and computing platform (e.g. PC, smart phone). This model only specifies the UI components, their elements, and the navigation among the components.
 * Concrete user interface (CUI): this model is an adaptation of an AUI to a specific context of use (user preference, environment, and platform). For example, for visually handicapped person, an output abstract component could be transformed to a (concrete) vocal output.

==Method==

Our MDE method consists in 3 main steps:

 * Modeling: where the WSCs are modelized within its user interactions by a designer using the UI-WSC.
 * Transformation: where the AUI is derived by applying transformations to the UI-WSC model. 
 * Adaptation: where the CUI is derived from the AUI and the context of use. Additionally, the user can interact with the CUI through an interpreter, while a runtime component arbitrates the communication between the CUI and the WSC.

= Components =

*Describe what is a component.*

==  Modeling Component ==

Where the WSC can be specified with the user interactions, through a modeling tool. The modelization of the user interactions is materialized by an extension of a WSC language. The extension will be based on two standards: 1) BPEL, the de-facto standard for WSC; and 2) UsiXML link, an emerging standard for describing user interfaces.

==  Deployment Component ==

Where the AUI is derived by applying transformations by the WSC created on the previous component. We adopt the standard proposed by the UsiXML to modelize the AUIs. Additionally, this component is responsible to apply other transformations in order to generate an executable version of the process in BPEL.

==  Runtime Component ==

Where the CUI is generated from the AUI and the context of use. This component can rely on the current works to generate the CUI, such as UsiXML or MARiA link. Additionally, the user can interact with the CUI through an interpreter, while the runtime component arbitrates the communication between the CUI and the WSC.