#summary Description of UI BPEL's Architecture.

= Introduction =

The UI BPEL extension is a piece of the integrated system for providing User Interfaces (UI) for Web service compositions (WSC) specified through BPEL. The overall architecture of the system is shown in following Figure, which partitions its software components into design time, deployment time, and runtime components.

<img src=http://svn.codespot.com/a/eclipselabs.org/bpel-ui/wiki/images/archicture.png title="UI BPEL meta-model" width=600>

== Design Time ==

The design part comprises the UI BPEL editor with the new activities and elements proposed by the UI BPEL metamodel. In this tool, the WSC designer can describe BPEL processes and define the user interaction presents on it, and the editor generates a corresponding UI BPEL specification as output. This tool is an extension to Eclipse BPEL Editor that adds: (i) a palette that allows the designer to specify the user interaction activities by dragâ€™n drop them on the BPEL process and (ii) a property panel that allows the designer to set the properties of the user interaction activities based on the UI BPEL meta-model.

== Deployment Time ==

The deployment of a UI orchestration requires translating the UI BPEL specification, which is not immediately executable neither by a standard BPEL engine nor by the UI rendering interpreter (the so-called UI interpreter, which we discuss in the following), into executable formats. This task is achieved by the UI BPEL processor, which, starting from the UI BPEL model, it generates three kinds of outputs: 

 # A standard BPEL specification containing only web service orchestration logic. Unlike the UI BPEL model, the generated BPEL specification does no longer contain any of the UI-specific constructs introduced in [link] and can therefore be executed by any standards-compliant BPEL engine. This means that all references to user interactions activities are rewritten into references to the respective operation at the mediator server. More information about the transformation and mediation can be found [link] and [link].

== Runtime ==

TODO

==Artifacts==

Our approach relies on X artifacts:
 
 * UI-WSC:  an extension of WSC with user interaction activities. To be compliant with current standards, the model is to rely on existing standards: a standard for WSC (e.g. BPEL) and a standard for describing user interfaces (e.g. UsiXML).
 * Abstract user interface (AUI): this model describes the UI independently to any interaction modality (e.g. graphical modal, vocal modal) and computing platform (e.g. PC, smart phone). This model only specifies the UI components, their elements, and the navigation among the components.
 * Concrete user interface (CUI): this model is an adaptation of an AUI to a specific context of use (user preference, environment, and platform). For example, for visually handicapped person, an output abstract component could be transformed to a (concrete) vocal output.

==Method==

Our MDE method consists in 3 main steps:

 * Modeling: where the WSCs are modelized within its user interactions by a designer using the UI-WSC.
 * Transformation: where the AUI is derived by applying transformations to the UI-WSC model. 
 * Adaptation: where the CUI is derived from the AUI and the context of use. Additionally, the user can interact with the CUI through an interpreter, while a runtime component arbitrates the communication between the CUI and the WSC.

= Components =

*Describe what is a component.*

==  Modeling Component ==

Where the WSC can be specified with the user interactions, through a modeling tool. The modelization of the user interactions is materialized by an extension of a WSC language. The extension will be based on two standards: 1) BPEL, the de-facto standard for WSC; and 2) UsiXML link, an emerging standard for describing user interfaces.

==  Deployment Component ==

Where the AUI is derived by applying transformations by the WSC created on the previous component. We adopt the standard proposed by the UsiXML to modelize the AUIs. Additionally, this component is responsible to apply other transformations in order to generate an executable version of the process in BPEL.

==  Runtime Component ==

Where the CUI is generated from the AUI and the context of use. This component can rely on the current works to generate the CUI, such as UsiXML or MARiA link. Additionally, the user can interact with the CUI through an interpreter, while the runtime component arbitrates the communication between the CUI and the WSC.